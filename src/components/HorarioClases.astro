---
import { supabase } from "../lib/supabase";
import turnos from "../assets/turnos.json";
import MiniGuardiaCard from "./MiniGuardiaCard.astro";

// 1. Primero obtenemos el turno al que pertenece el usuario
let turno;

// Get current session
const {
  data: { session },
} = await supabase.auth.getSession();
if (!session) throw new Error("User is not logged in");

// Fetch the user record from 'usuarios' using .single()
const { data: user, error: userError } = await supabase
  .from("usuarios")
  .select("*")
  .eq("auth_id", session.user.id)
  .single();
if (userError) throw userError;

const { data: turnoData, error: turnoError } = await supabase
  .from("horarios_profesor")
  .select("turno, inicio")
  .eq("id_profesor", user.id)
  .single();

if (turnoError) throw turnoError;

turno = turnoData?.turno;

// 2. Sacamos todas las guardias para el día de hoy
const today = new Date().toISOString().split("T")[0];
const turnoActual = turnos[turno];

if (!turnoActual) {
  throw new Error("Turno no válido");
}

const inicioTurno = `${today}T${turnoActual[0].start}:00`;
const finTurno = `${today}T${turnoActual[turnoActual.length - 1].end}:00`;

const { data: guardiasHoy, error: guardiasError } = await supabase
  .from("guardias")
  .select("*")
  .gte("inicio", inicioTurno)
  .lte("fin", finTurno);

if (guardiasError) throw guardiasError;

// 3. Dividir las guardias en función de su tramo horario definido en turnos.json

const slotKeys = [
  "primera",
  "segunda",
  "tercera",
  "recreo",
  "cuarta",
  "quinta",
  "sexta",
  "septima",
];
const guardiasPorTramo = slotKeys.reduce((acc, key) => {
  acc[key] = [];
  return acc;
}, {});

// Función auxiliar para extraer "HH:MM" sin conversión de zona horaria
function extraerHoraMinutos(timestamp) {
  return timestamp.slice(11, 16);
}

guardiasHoy.forEach((guardia) => {
  const guardiaStart = extraerHoraMinutos(guardia.inicio);
  const guardiaEnd = extraerHoraMinutos(guardia.fin);

  turnoActual.forEach((slot, index) => {
    if (slot.start === guardiaStart && slot.end === guardiaEnd) {
      const key = slotKeys[index];
      guardiasPorTramo[key].push(guardia);
    }
  });
});
---

<div class="guardias-table">
  <table>
    <thead>
      <tr>
        {
          turnoActual.map((slot) => (
            <th>
              {slot.start}-{slot.end}
            </th>
          ))
        }
      </tr>
    </thead>
    <tbody>
      <tr>
        {
          slotKeys.map((key) => (
            <td>
              <div class="time-column">
                {guardiasPorTramo[key].length > 0 ? (
                  guardiasPorTramo[key].map((guardia) => (
                    <MiniGuardiaCard guardia={guardia} user={user} />
                  ))
                ) : (
                  <div class="empty-slot">
                    <span style="padding: 10px; border-radius: 10px; background-color: white;">
                      Vacío
                    </span>
                  </div>
                )}
              </div>
            </td>
          ))
        }
      </tr>
    </tbody>
  </table>
  

  <script>
    function updateTimeline() {
      const now = new Date();
      now.setHours(19, 30, 0, 0); // Set to 19:30 for testing
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const currentTimeInMinutes = currentHour * 60 + currentMinute;

      // Extract time slots from thead
      const timeSlots = Array.from(
        document.querySelectorAll(".guardias-table thead th"),
      ).map((th) => {
        const [start, end] = th.textContent?.split("-") || [];
        return { start, end };
      });

      // Convert time to minutes
      function timeToMinutes(time) {
        const [hour, minute] = time.split(":").map(Number);
        return hour * 60 + minute;
      }

      // Find current slot and position within it
      let currentSlotIndex = -1;
      let positionInSlot = 0;

      timeSlots.forEach((slot, index) => {
        const startMinutes = timeToMinutes(slot.start);
        const endMinutes = timeToMinutes(slot.end);
        if (
          currentTimeInMinutes >= startMinutes &&
          currentTimeInMinutes < endMinutes
        ) {
          currentSlotIndex = index;
          const slotDuration = endMinutes - startMinutes;
          const elapsedInSlot = currentTimeInMinutes - startMinutes;
          positionInSlot = (elapsedInSlot / slotDuration) * 100; // Percentage within the slot
        }
      });

      // Position the line if within a slot
      if (currentSlotIndex !== -1) {
        // Get the th element for the current slot
        const thElement = document.querySelectorAll(".guardias-table thead th")[
          currentSlotIndex
        ];
        const columnLeft = (thElement as HTMLElement).offsetLeft; // Left position of the column
        const columnWidth = (thElement as HTMLElement).offsetWidth; // Width of the column
        const lineLeft = columnLeft + (positionInSlot / 100) * columnWidth; // Position within the column

        // Create or update the timeline element
        let timeline = document.getElementById("current-time-line");
        if (!timeline) {
          timeline = document.createElement("div");
          timeline.id = "current-time-line";
          document.querySelector(".guardias-table")?.appendChild(timeline);
        }
        timeline.style.left = `${lineLeft}px`; // Set horizontal position
      }
    }

    // Initial update
    //updateTimeline();

    // Update every minute
    //setInterval(updateTimeline, 60000);

    // Creación de la tabla dinamicamente
  </script>
</div>

<style>
  .guardias-table {
    overflow-x: auto;
    width: 100%;
    border: 1px solid #ddd;
    background-color: white;
    position: relative;
    margin-bottom: 20px;
  }

  .guardias-table table {
    width: 100%;
    border-collapse: collapse;
  }

  .guardias-table thead th {
    position: sticky; /* Fija el encabezado en la parte superior */
    top: 0;
    background: #f5f5f5; /* Fondo para que no se trasluzca el contenido */
    padding: 1rem;
    text-align: center;
    border-right: 1px solid #ddd;
    z-index: 10; /* Asegura que esté sobre el contenido */
    min-width: 140px; /* Ancho mínimo para las columnas */
  }

  .guardias-table tbody td {
    border-right: 1px solid #ddd;
    vertical-align: top;
    height: 300px; /* TODO cambiar esto */
    overflow-y: auto; /* Scroll if content overflows */
  }

  .time-column {
    display: flex;
    flex-direction: column;
    height: 100%; /* Fill td height */
    gap: 0.5rem;
  }

  .empty-slot {
    flex-grow: 1; /* Expand to fill available space */
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(252, 196, 92, 0.877);
  }

  #current-time-line {
    position: absolute;
    top: 0; /* Start at the top of .guardias-table */
    width: 2px; /* Thin vertical line */
    height: 100%; /* Span the full height of the table */
    background: red;
    z-index: 100; /* Ensure it’s above other content */
  }
</style>
